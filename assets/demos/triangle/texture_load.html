<!DOCTYPE html>
<head>
    <style>
        body{
            width:100%;
            height: 100%;
            margin:0px;
            padding:0px;
            overflow:hidden;
        }

        canvas{
            width:100%;
            height:100%;
            margin:0px;
        }
    </style>
</head>
<body>
    <script>
        const canvas = document.createElement("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const gl = canvas.getContext("webgl2");
        document.body.appendChild(canvas);
        const vertex_code = `#version 300 es
            precision highp float;
            layout(location=0) in vec2 aPos; // position attribute bound at location 0
            layout(location=1) in vec3 aCol; // color attribute bound at location 1
            layout(location=2) in vec2 aUv;

            out vec3 vCol; // varying color data which is passed on to the fragment shader
            out vec2 vUv;

            void main(){
                vCol = aCol;
                vUv = aUv;
                gl_Position = vec4(aPos, 0.0, 1.0);
            }
        `;

        const fragment_code = `#version 300 es
            precision highp float;

            uniform sampler2D uTex;

            in vec3 vCol; // the varying color data from vertex shader
            in vec2 vUv; // the varying uv data from vertex shader
            out vec4 outCol; // output fragment color

            void main(){
                outCol = texture(uTex, vUv);
            }
        `;

        const vertex_shader = gl.createShader(gl.VERTEX_SHADER);
        const fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);

        gl.shaderSource(vertex_shader, vertex_code);
        gl.compileShader(vertex_shader);

        if(!gl.getShaderParameter(vertex_shader, gl.COMPILE_STATUS)){
            throw new Error("failed to compile vertex shader:" + gl.getShaderInfoLog(vertex_shader));
        }

        gl.shaderSource(fragment_shader, fragment_code);
        gl.compileShader(fragment_shader);

        if(!gl.getShaderParameter(fragment_shader, gl.COMPILE_STATUS)){
            throw new Error("failed to compile fragment shader:" + gl.getShaderInfoLog(fragment_shader));
        }

        const shader_program = gl.createProgram();
        gl.attachShader(shader_program, vertex_shader);
        gl.attachShader(shader_program, fragment_shader);
        gl.linkProgram(shader_program);

        if(!gl.getProgramParameter(shader_program, gl.LINK_STATUS)){
            throw new Error("failed to link shader program: "+ gl.getProgramInfoLog(shader_program));
        }

        const uTexLoc = gl.getUniformLocation(shader_program, "uTex");

        const vertex_pos_data = new Float32Array([
            -1.0, -1.0, 
             1.0, -1.0, 
             0.0,  1.0
        ]);

        const vertex_color_data = new Uint8Array([
            255,   0,   0,
              0, 255,   0,
              0,   0, 255
        ]);

        const vertex_uv_data = new Float32Array([
            0.0, 1.0,
            1.0, 1.0,
            0.5, 0.0
        ]);

        const vertex_pos_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_pos_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertex_pos_data, gl.STATIC_DRAW);
        
        const vertex_color_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_color_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertex_color_data, gl.STATIC_DRAW);

        const vertex_uv_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_uv_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertex_uv_data, gl.STATIC_DRAW);

        const vao = gl.createVertexArray();

        gl.bindVertexArray(vao); // next gl operations will be "recorded" in the vao

        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_pos_buffer);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(
            0, // attribute index: 0: aPos
            2, // num elements per attrib value: vec2
            gl.FLOAT, // buffer data type: float
            false, // should data be normalized into 0.0 - 1.0 range when read in shaders
            0, 0 // not important for now
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_color_buffer);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(
            1, // attribute index: 1: aCol
            3, // num elements per attrib value: vec3
            gl.UNSIGNED_BYTE, // buffer data type uint8
            true, // 0 - 255 is normalized to 0.0 - 1.0 range when read in saders
            0, 0 // not important for now
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_uv_buffer);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(
            2, // attribute index: 2: aUV
            2,
            gl.FLOAT,
            false,
            0,0
        );

        gl.bindVertexArray(null); // end the "recording"
        gl.bindBuffer(gl.ARRAY_BUFFER, null); // clear the binding just in case

        const pixel_data = new Uint8Array([
            255,  0,  0,255,        0,255,  0,255,
            255,255,  0,255,        0,255,255,255
        ]);

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel_data);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

        const image = new Image();
        image.onload = ()=>{
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            draw();
        }
        image.src = "./tex.png";

        function draw(){
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.clearColor(0,0,0,1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // start drawing the triangle
            gl.useProgram(shader_program);
            gl.bindVertexArray(vao);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        
    </script>
</body>